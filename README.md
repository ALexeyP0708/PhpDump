# Alpa\PhpDump  
## Вывод дамп данных в консоль браузера.   

* Выводит ошибки  в консоли.
* Выводит переменные в консоли.
* Выводит массивы и объекты в консоли.
* Выводит детальную информацию об объектах и классах рекурсивно.  
* Возможность анализа "Тяжелых объектов"  
* Отсутствие ограничения вложенности в объектах за счет исключения петель(замыкания по ссылки).  

#### Принцип реализации:  

1. Служебная информация между клиентом и сервером обменивается через заголовки. 
2. После клиент запрашивает тело дампа  для вывода результата в консоли.
3. При формировании дампа, данные дампа в потоке записываются в json файл и после, при запросе клиентом, 
данные json файла отдаются клиенту.  
4. Дамп  можно включать и отключать для конкретных вкладок.  
5. Отображает дамп Ajax запросов.  
5. При желании, возможность анализировать дамп через файл.
6. Ничего лишнего и ни какого пафоса.   

**Перспективы:**
- Передача дампа через web socket . Тем самым сегменты дампа будут сразу передаваться клиенту, даже если скрипт вошел в цикличную бесконечность  
- Возможность привязки вкладки к работе конкретного скрипта. Это необходимо когда скрипт выполняется чере CLI или запущен демон.  
- Управление приложением через команды.  
- При цикличности, исключить передачу повторных данных.  
- Импорт экспорт дампа.

## Быстрый старт.

1. Необходимо установить расширение для Google Chrome (в режиме разработчика) из каталога ChromeExtension/PhpDumpConsole_v1.1 .
В панели появится красный значек в виде прицела (шестеренка в кругу).
Если при нажатии шестеренка не превращается в синий цвет, то или сервер не поддерживает PhpDump или клиент не прошел авторизацию.

2. Запустить тест tests/test_debugManager.php
Если PhpDump запустился, то Ура работает.

3. Для дальнейшей работы, можете отредактировать файл настроек.
	
### Файл настроек. **"src/include_file_in_index.php"**  
В файле настроек можно включать отключать PhpDump, или ограничивать запись дампа конкретными данными,
включать отключать бектрейс, изменять каталог сохранения файлов дампа.  
Также в файле можно объявить свои функции-обертки для конкретных методов или назначить псевдоним для рабочего класса.
Также в файле настроек устанавливаются настройки авторизации. 

#### Авторизация.  

Принцип авторизации устроен просто.  Шпионское приветствие.  
Клиент передает ключ хеш (хешкей)  и  свою парольную фразу.  
Сервер по хешкею сравнивает парольную фразу и если окей, отправляет свою парольную фразу.  
Далее клиент начинает работать с сервером.  
На основании hashkey, Сервер может регистрировать множество клиентов. А клиент может работать с множеством серверов.  
В будущем возможна авторизация поменяется.  
 
```php
	$settings=[
	'hashkeys'=>[
		'HashKey'=>[
			'key'=>'HashKey',
			'greeting_server'=>'greeting_server',
			'greeting_client'=>'greeting_client'
		]
	]
];
 ```

#### Минимальные настройки дампа

```php
$dump_settings=[ 
	'turn_on'=>['all'=>true], 
	'unset_dump_after'=>true, 
	'debug_backtrace'=>false
];
$dump_fields=[
	'path'=>__DIR__.'/../temp', 
	//'user'=>'', // Can be changed by the client part (via the browser console)
	//'context'=>'',// Can be changed by the client part (via the browser console)
	//'group'=>'', //Can be changed by the client part (via the browser console)
	//'name'=>'', // only for server part
];
```

Если необходимо отключить работу дампа, достаточно указать `$dump_settings['turn_on']=false;  `
Если необходимо включить дамп, то укажите в настройках массив `$dump_settings['turn_on']=[];` Данным массивом может управлять клиент.
В массиве можно перечислить сегменты данных которые вы хотите отключить или включить для их вывода указанных под  меткой.
Парсинг Меток реализован специально под пространство имен.  И если вы ходите отключить или включить группу меток,
 то достаточно указать пространство имен этой группы.  
 К примеру есть метки категории "Producer\Product\Class" и метки категории "Producer\Product\Class2  
```php
 // Отключаем все метки кроме ошибок и меток категории "Producer\\Product\\Class"
 $dump_settings['turn_on']=['all'=>false,'Errors':true,'Producer\\Product\\Class'=>true]; 
 // Отключаем все метки кроме ошибок и меток категории Producer\\Product. Данные с метками Producer\\Product\\Class и Producer\\Product\\Class2  будут отображаться 
 $dump_settings['turn_on']=['all'=>false,'Errors':true,'Producer\\Product'=>true]; 
 // Отключаем вывод ошибок с кодом 1024 и данные с меткой Producer\\Product::method
  $dump_settings['turn_on']=['all'=>true,'Errors\\1024':false,'Producer\\Product'=>false];
 ```
 Если необходимо вывод backtrace  
```php
	$dump_settings['debug_backtrace']= true;
```

Если вы хотите оставлять сгенерированые файлы дампов, то: 
```php
	$dump_settings['unset_dump_after']= false;
```

Если необходимо изменить каталог сохранение файлов дампа:
```php
	$dump_fields['path']='new dirictory';
```

Файлы имеют некий путь сохранения и строятся по следующему принципу:  

`user/context/timestamp_group_name.json`

```php
	//если необходимо группу файлов дампа выделить под конкретным пользователем. По умолчанию или  сессия или other_user Определяется сервером.
	$dump_fields['user']='name';
	// Если необходимо выделить некую группу файлов в рамках контекста (в рамках одной вкладкой или псевданима). По умолчанию клиент передает номер вкладки.   Назначается только клиентом.
	$dump_fields['context']='num_tab';
	// если файлы дампа необходимо сгруппировать. Например для выполнения конкретных сценариев. По умолчанию случайное число. Может определяться клиентом.  сервер переопределяет.
	$dump_fields['group']='name_group';
	// указывает суфикс названия (имя) файла. Генерируется динамически. Определяет только сервер.  
	$dump_fields['name']='name';
```
При изменении настроек для $dump_fields на сервере, они начнут применяться только для новых вкладок.  
При использовании PhpDump несколькими пользователями в категории other_user и при совпадении контекста "context"(например одинаковый id вкладки),
есть шанс что случайные числа для 'group' и 'name' пересекутся и возникнет конфликт формирования файлов дампа (создание файла под одним и тем же именем или чтение чужого дампа).  
Но такой шанс не велик, так как  PhpDump будут использовать одновременно небольшая группа разработчиков для одного сервера.  
Если все таки хотите свести конфликт к минимуму, то   можно сделать так $dump_fields['name']=uniqid().uniqid().uniqid(); или задайте иную логику.
Некоторые настройки можно менять со стороны клиента.

Итак после настройки, для осуществления записей в дамп, необходимо объявить файл настроек в самом начале выполнения сценария скрипта.   
Как правило это файл index.php. 
```php
	inclede_once __DIR__.'[paths]/src/include_file_in_index.php';
``` 
Почему должен объявляться в самом начале*?. Так как после выполнения сценария , 
клиент у этой же страницы запрашивает дамп. После как дамп передан клиенту, скрипт прекращает выполнение.  
  
вместо inclede_once \_\_DIR\_\_.'[paths]/src/include_file_in_index.php';
можно просто обьявить  класс InitDump. 
```php
	 new Alpa\PhpDump\InitDump();
```
В файле настроек, для удобства  для класса Alpa\PhpDump\Manager указан псвдоним \deb, который реализует статические методы для выполнения записи данных в дамп.  

Статические Методы класса \deb для использования в PHP сценарии:
```php
	\deb::vdump($var,$label='')// - результат выполнение var_dump 
	\deb::vexport($var,$label='');//- результат выполнение var_export
	\deb::print($var,$label='');// - выводит результат переменной. (в том числе массивы и объекты, рекурсивно анализируя)
	\deb::dump($var,$label='')// - также выводит результат переменной. Если массив или объект, рекурсивно анализирует их. По каждому обьекту предоставляет детальную информацию.
	\deb::error($errno = false, $errstr, $errfile = false, $errline = false, $errcontext = false)
```

## Работа в Консоли браузера.


При включении приложения для вкладки, страница сайта перезагрузится. PhpDump перейдет в рабочее состояние.
При этом инициализируются первичные настройки для вкладки и для сервера.
Последующие полученные настройки со стороны сервера являются динамическими (настройки сформированные клиентом и сервером)
 и действуют в момент существования вкладки и не сохраняются при ее закрытии или отключения для нее PhpDump расширения.

Возможно покажется не удобным, но для управления сервером и клиентом используется консоль и вызов соответствующего API.
Чтобы применить это api в действии, необходимо в консоли из списка приложений 
(выпадающий список. размещается в верхнем левом углу консоли и отображается по умолчанию "top") выбрать  PhpDumpConsole. 

#### API  для работы в консоле
>* dm - обьект для работы с методами команд
>* dm.renderStack(); -вывод в консоль стек данных дампа  по всем запросам страницы
>* dm.renderDump(); Вывод в консоль объект дампа
>* dm.renderSettings(callback=false); отображает настройки для данной страницы(по url). 
callback function если указан то обработает результат callback -ом.   
>* dm.setSettings(settings,save=false);// настройки для сайта, которые будут применимы в ходе запросов к серверу. 
save=true настройки будут сохранены и будут применимы постоянно
save=false настройки будут применены, пока работает браузер или расширение для вкладки.
settings - массив объектов-настроек
```js
	// dm - обьект для работы с методами команд
	dm.renderStack();//вывод в консоль стек данных дампа  по всем запросам страницы
	dm.renderDump(); //Вывод в консоль обьект дампа
	dm.renderSettings(callback=false); //отображает настройки для данной страницы(по url). callback function если указан то обработает результат callback -ом.   
```
```js	
	var settings=[{
			url:'', // урл к которому будут применены настройки. по умолчанию  window.location.href. 	  
			regexp:'', // регулярное выражение для дочерних ресурсов сайта. url  и regexp работают в паре см.  `url=url.trim()!=''?'^'+$url:''; new RegExp(url+regexp,'i');
			turn_on:{ // см PHP $dump_settings['turn_on']
				'all':false ,  
				'group2\\group1':true, 
				'group3':true,
				'namespace/name':true, 
			}, 
			debug_backtrace:false, см PHP $dump_settings['debug_backtrace']
		}];
	dm.setSettings(settings,save=false); // устанавливает настройки для сайта  и паттерну для него.  save =true -настройки сохранятся, и будут применяться постоянно.
	/*
		**Внимание**: чтобы изменить настройки для сайта  которые были введены ранее, то параметры url и regexp должны совпадать с параметрами сравнения.
		в противном случае эти настройки будут добавлены как новые.
		Также если несколько таких правил будут совпадать с url то настройки будут объединяться рекурсивно при вычислении настроек сайта, а
		при совпадении свойств - заменены  последними настройками в стеке настроек. (принцип рекурсивного объединения массивов) 
	*/
```

```js	
	var settings =[{url:'url',regexp:'regexp',type:'link'}];
	dm.clearSettings(settings,save=false); //сбрасывает настройки.
	// type ='link', сбрасывает все настройки, чьи паттерны подходят к url.
	// type!='link', сбрасывает все настройки чьи паттерны идентичны сформированному рег выражению. формирование выражения см. setSettings();.
	// save =true сохранит сброс.
```

```js
	dm.clearAllSettings(save=ture/false); // сбрасывает все настройки
	dm.saveStorageAllSettings(); // сохраняет все изменения , произошедших в настройках.
``` 

```js
//Авторизация
	param={
		hashkey:'HashKey', // ключ по которому проходит авторизация. он может привязываться к любому домену. 
		greeting_server:'greeting_server', // приветствие сервера. пароль сервера. тем самым сервер авторизуется с клиентом. 
		greeting_client:'greeting_client' // приветствие клиента. пароль клиента.  для авторизации клиента с сервером.
	}
	dm.setHashKey(param); // регистрируем/изменяем хашкей 
	dm.deleteHashKey({hashkey:'name'}); // удаляет хашкей.
	dm.bindHashKeyDomain({hashkey:'HashKey',domain:'qwer.qw'});//привязывает хашкей к домену.  тем самым по этому хашкею можно авторизироваться с доменом. 
	//если domain='global' хашкей будет применяться для сайтов к которым не установлен хашкей.  
	dm.unbindHashKeyDomain({domain:'ggg',hashkey:'ggg'});// отвязывает хашкей от домена...
	dm.getAuthHashKeys(callback=false); // запрашивает хашкеи 
	//если  callback =function(data_return){} то обработает запрошенные данные калбеком. Это необходимо порой для проверки и зачистки не нужных хашкеев. 
```

## Возможные проблемы.

E_ERROR: Allowed memory size of ******** bytes exhausted 

Переменная дампа содержит очень большой объект для анализа. Т.к как объект анализируется и по каждому дочернему свойству создается статистика.
Также проблема кроется в json_encode, так как под  json строку выделяется память, а не передается результат в поток.
Решение - увеличить объем памяти в php.
Над проблемой бьются лучшие умы.  НО пока всех все устраивает если не зажираться.  

HTTP ERROR 500 - критическая ошибка  
Если сценарий прекратил Apache (или иной сервер)  то  дамп  не сформируется. При запросе дампа, PhpDump отдаст не сформированный дамп. Клиентская часть не сможет его распознать. 
Для этого придется анализировать в фоновой странице приложения в разделе NETWORK запросы или анализировать файлы дампа. 
 (чтобы файл распознавался json декодерами, при таком аварийном закрытии, надо в конце добавлять квадратную и фигурную скобки -"]}" ) 
 
Если от сервера получен ответ 500 или иные ошибки без погрузки контента (скрипт расширения PhpDumpConsole для контента не будет загружен), то в консоли соответственно ничего не выдаст.  Это связано с тем что, после загрузки страницы, загружается скрипт контента приложения и обменивается данными с приложением.  
Приложение дублирует ответ в консоли фоновой страницы расширения PhpDumpConsole.    
Поэтому ответ можно проанализировать там.  
См Chrome Extensions фоновая страница приложения.

Для ознакомления с обозначениями свойств и методов объекта см https://github.com/ALexeyP0708/EntityDetails



